##########################################################################################
# This R script processes the output files of the LepMAP2 OrderMarkers module. It extracts
# data from the OrderMarkers output .SA.txt files (one for each Linkage Group) and 
# anaylzes, organizes, and tabulates the data. It also combines this data with the data
# in the original input .csv file, and chooses just one marker to represent each gene. For 
# example, if a gene has 5 markers, the markers will be compared, and the marker whose
# position is nearest the median position of all 5 markers, has the most complete data,
# and has the lowest error_estimate will be chosen to represent that gene in the final
# output. 
#
# This script produces several output data files: one main .csv file and several other 
# supporting .csv and .txt files. Details on these files are below.
# 
# In addition to the OrderMarkers .SA.txt input files, a map file such as those generated 
# by the LepMAP2 SeparateChromosomes and JoinSingles modules must be present as input, as
# well as the original data in .csv format.
#
# Although this script does not itself use LepMAP2, background information on LepMAP2 can
# be found at:
# https://sourceforge.net/p/lepmap2/wiki/browse_pages/
#
#
##########################################################################################
# To run this script:
#
#
# - (1) First, you need to make sure your input files are all in one directory, and are
# each formatted properly. Required input files are:
#         - a .csv file of the original input data, before running LepMAP2 on it. The 
#           first column should contain marker ids, and the remaining columns correspond
#           to samples.
#         - one .SA.txt file (generated by LepMAP2 OrderMarkers) per Linkage Group.
#         - a map file (generated by LepMAP2 SeparateChromosomes, JoinSingles, or by
#           this script, or even by yourself manually. This map file should be the same 
#           one that was used to run OrderMarkers. So, for example, if you ran 
#           SeparateChromosomes (which generates a map file whose name ends with
#           "-map.txt"), then JoinSingles (which generates an updated map file whose name
#           ends with "-map_js.txt"), then OrderMarkers, you will want to use the map file
#           generated by JoinSingles. The format of this file is simple:
#           each line in the map file corresponds to the same line number in the original
#           .csv data file, and contains only an integer corresponding to the assigned
#           Linkage Group of that marker, or 0 if it hasn't been assigned to a Linkage 
#           Group. The first line should be a comment/header beginning with "#".
#
#
# - (2) Second, open the script in a text editor, edit the input parameters (see the 
# Input Parameters section below), and save the file. It is good practice to make a copy 
# of the file first and edit the copy in case you mess something up. If you make a copy
# with a new file name, use the new file name in the commands below instead of the
# original script name.
#
#
# - (3) Third, and finally, execute the command to run the script. You can either do 
# this from within the R console, or by using the commandline tool Rscript. 
# To use the commandline tool Rscript, from the commandline, make sure you are in the 
# same folder as the script, and type:
#    Rscript scriptname.R
# To run the script from within the R console, from the commandline, make sure you are 
# in the same folder as the script, and type:
#    R
# This opens the R console. Then type:
#    source("scriptname.R")
#
#
# Output expected from this script:
# The output files will be written to the same folder that the input files are in. There
# are 6 output files:
#
# -allChr-uniqueGenes.csv:
# This is the main output. It contains only those genes whose markers are not found in 
# more than one Linkage Group. Additionally, a single representative marker is chosen for 
# each gene, so it will only have one row per gene. Each row contains linkage group id, 
# gene id, and statistical information for that gene, followed by the chosen marker id and 
# the data of the chosen marker. Representative markers are chosen by finding the marker 
# nearest the median marker position with the lowest error and most complete data to 
# represent the gene. Here is information on the data columns:
#     linkage_group   - the linkage group (numeric) that the gene belongs to
#     gene            - the gene identifier
#     total_markers   - the total number of markers of that gene
#     max_pos         - the max position of all the marker positions we have of that gene 
#     min_pos         - the min position of all the marker positions we have of that gene 
#     median_pos      - the median position of all the marker positions we have of that gene
#     total_distance  - the distance between the max and min marker positions
#     median_distance - the median distance between adjacent marker positions
#     marker_id       - the id of the marker chosen to represent the gene
#     marker_number   - the marker number of the chosen marker, corresponding to the 
#                       marker_number value in the OrderMarkers output file, and the line
#                       number (excluding the header line) of that same marker in the  
#                       input map file and input csv file.
#     position        - the position of the chosen representative marker
#     error_estimate  - the error_estimate (from the OrderMarkers output file) of the 
#                       chosen representative marker
#     ...all remaining columns are the data of the chosen marker, drawn from the input 
#     .csvfile.
#
# -allChr-uniqueGenes-justTheMarkers.csv:
# This is a version of the main output, but with all statistical and metadata 
# columns removed, leaving just the chosen marker ids and their data. The reason this file 
# is created is because sometimes you will want to run a second iteration of LepMAP2 
# OrderMarkers on the output of the first iteration, and this is the format that the input 
# .csv file must be in to convert it to a .linkage file to be used by OrderMarkers.
#
# -allChr-uniqueGenes-map_js.txt:
# This is a map file that corresponds with the main output data. This can be used as the 
# input map file for a second iteration of LepMAP2 OrderMarkers, alonside a .linkage file 
# of the main data.
#
# -allChr-uniqueGenes-genesInMoreThanOneLG.csv:
# This everything that was excluded from the main output .csv file. I.e. all genes who
# have markers in more than one LG are excluded from the main output, and saved in this 
# file instead.
# 
# -allChr-uniqueGenes-PinusConsensusLGs.csv:
# This is a version of the main output data with the Linkage Group ids modified to match
# the Pinus Consensus linkage group ids. How our LG numbers match with the Pinus Consensus
# LG ids likely to change on a case-by-base, so this file will MOST LIKELY BE INCORRECT or
# it might even cause an error when the script tries to generate it unless you actually
# examine the code that does the matching and update it accordingly (do a search for 
# "ourLG ==" to find where in the code to make the changes). You might not even need this
# file, in which case you won't care about this.
#
# -allChr-uniqueGenes-PinusConsensusLGs-map_js.txt:
# This is a map file corresponding to the -allChr-uniqueGenes-PinusConsensusLGs.csv file,
# using the Pinus Consensus LG ids.
# 
#
##########################################################################################
# Input Parameters:

# path: The directory path of the folder that the input files are in. This is also the 
# folder that the output files will be saved to.
path <- "/home/benrancourt/Downloads/r45-LepMAP2-final-copyForTesting/r45-inThreeStages/test1"

# csvFilenameMinusExtension: The name of the .cvs input file, minus the ".csv" extension.
csvFilenameMinusExtension <- "r45-60592-p0.01"

# mapFilename: The name of the input map file. Information on this map file is given in
# the "To run this script" instructions above, under the first (1) step.
mapFilename <- "r45-60592-p0.01-map_js.txt"

# orderMarkersFilenamesMainPart: It would be tedious to supply the file name of every
# output file from the LepMAP2 OrderMarkers module, since every linkage group has it's own
# output file. Instead, we can take advantage of the expected naming convention of these
# files, and just supply the first part of the filename that they all share in common. Take
# a look at the OrderMarkers output files and find the part of the filename that comes
# before "-chr". That's the part that you want to enter for this parameter.
# More specifically, the OrderMarkers output filenames are expected to follow this 
# convention:
#      <orderMarkersFilenamesMainPart>-chr<LG>.SA.txt
# where "<orderMarkersFilenamesMainPart>" is replaced with the value you specify for it here,
# and "<LG>" is replaced with an integer indicating the Linkage Group number. Eg:
#      myFileName-chr4.SA.txt
# If your OrderMarkers output files don't follow this convention, you'll either have to 
# rename them or update some of the code in this script.
orderMarkersFilenamesMainPart <- "r45-60592-p0.01-map_js"

# separatorForGeneNameVsMarkerId: This parameter relates to the marker ids in the original
# .csv data file that you supplied. The marker id column in your input .csv file contains
# marker ids, which are composed of 
# a gene id joined to a string that uniquely identifies each marker of a gene. There should
# be a separator character between the gene portion of the id and the marker portion of the
# id. For example, the marker id "*M100356-1324K" is composed of two parts: the gene part
# (*M100356), and the marker part (1324K), separated by a "-". Common separators are "-" and
# "_". All id's in your input .csv file must use the same separator character to
# differentiate the gene portion from the marker portion. This script uses the separator 
# character to extract the gene id from the whole marker id string. It then uses the gene
# id when tabulating it's final output data. Please indicate what your input .csv file uses
# as the separator character.
separatorForGeneNameVsMarkerId <- "-"

# missingDataIndicator: This parameter relates to the data in the original
# .csv data file that you supplied. Some of the data in your original input .csv will
# likely be missing, in which case it might be represented as NA or "-" or maybe even be
# empty, or something like that to indicate that it is missing.
# Indicate what your .csv file uses to represent missing data.
missingDataIndicator <- "-"


# outputMapFileHeader: This will be used as a header for the map file that is generated to
# go along with the ouput data file of this routine. It must begin with a "#", to indicate
# it is a comment.
outputMapFileHeader <- paste0("#Linkage groups of tabulated output of tabulate_OrderMarkers_results.R performed on the output of LepMAP2 OrderMarkers on ",csvFilenameMinusExtension," data, ordered by linkage group, marker id.")






##########################################################################################
# Execution Code:

options(stringsAsFactors = FALSE, warn = 1)

message("Running tabulate_OrderMarkers_results.R.")

if(!require(stringr))
{
  install.packages('stringr', repos='http://cran.us.r-project.org')
}

library(stringr)

# #######################################################################
# Read .csv file
# Read -map_js.txt file
# Create a vector of unique Linkage Group (LG) ids from that file
# Read chrX.SA.txt files (one for each chromosome/linkage group)
# For each LG, create a dataframe of the markers in each LG:
#        - Col.1: LG
#        - Col.2: male_position from SA file
#        - Col.3: marker id (in col.1 of csv data) corresponding to that line number (next)
#        - Col.4: marker number from SA file (which is the line number in both map_js.txt and .csv file, excluding the header line from the count. e.g. the first data row would be line 1.)
#        - Col.5: error estimate from SA file
#        - Col.6: duplicate OR phases from SA file
#        - Col.7-n: the data columns from csv file
#        - sort by order of columns given above
# For each unique male_position (Col.2 above):
#        - find the ones that aren't listed as duplicates, 
#        - for each of these, find the ones listed as duplicates that share their gene (first part of marker id) and their error estimate
#        - then find in that group (including the non-duplicate) the one with the most complete data and save its rownum in a vector which we'll use at the end to take only those rows that we're not deleting.
# Delete all the rows we aren't keeping.
# Delete the duplicate/phases column.
# #######################################################################



# TODO:
# - parametrize the Pinus Consensus LG id matching

csvData <- read.csv( paste(path.expand(path),paste0(csvFilenameMinusExtension,".csv"),sep="/") )
numDataColsInCsvData <- ncol(csvData)-1
colnames(csvData)[1] <- "marker_id"
# we can set the marker_number sequentially like this because the marker_number in the
# Order Markers output file refers to the row number in both the .csv and the map file.
csvData$marker_number <- seq.int(nrow(csvData))

mapData <- read.table( paste(path.expand(path),mapFilename,sep="/") )
linkageGroups <- sort(unique(mapData)[ , 1])

# this will contain the combined and filtered data from all linkage groups in one table
finalUniqueGenes <- NULL

for (lg in linkageGroups) 
{
  if (lg == 0) 
  {
    next; # lg 0 is not a linkage group, skip to the next for-loop iteration
  }
  message(paste0("Processing linkage group ",lg))
  # The file output from the LepMAP2 OrderMarkers module is organized into space/tab
  # delimited columns, which the below read.table command reads in (it excludes the first few lines because they're metadata and don't match the column pattern):
  orderMarkersFile <- paste(path.expand(path),paste0(orderMarkersFilenamesMainPart,"-chr",lg,".SA.txt"),sep="/")
  orderMarkersData <- read.table(orderMarkersFile, col.names = c("marker_number","position","female_position","left_paren","error_estimate","right_paren","duplicate_or_phases"))
  
  # get rid of unnecessary columns:
  orderMarkersData <- subset(orderMarkersData , select=-c(female_position,left_paren,right_paren))
  
# #######################################################################
#(- create a new csv that removes all duplicates with error estimates that aren't the lowest)
#x- order all remaining data (including duplicates) by lg, gene, marker/snp id, error estimate, position
#??- remove all those whose error estimate is not the lowest??
#- for each gene:
#- find the highest and lowest position
#- calculate the distance between the highest and lowest
#- calculate the median position
#- calculate the median distance between adjacent positions (standard error?)
#- find the position closest to the median position
#   - if two equi-distant positions on either side of median
#      - pick the position with the most snps/markers at it, or if tied
#      - or pick the one with the most 0 error estimates, or if tied
#      - or pick the one with the snp that has the lowest error estimate, or if tied
#      - or pick the one with the snp that has the most complete data, or if tied
#      - or pick the one with the nearest/largest group of markers at an adjacent position, or if tied
#      - just pick the lower position
#- choose the snp/marker in that position with the (lowest error and) most complete data to represent the gene
#- remove all other markers of that gene
#- save in the table: lg, marker position, gene, num markers, dist betw highest and lowest pos, median dist between adjacent positions (std error?), median position, marker id, marker number, marker error est, csv data
#- remove all genes that occur in multiple LGs (create table: gene id, snp id, lg id, position, error estimate)
#      - after establishing that there's only one occurence of each gene per LG, search the gene column for any gene that appears more than once
#      - remove those rows to their own table
# #######################################################################

  combinedData <- merge(orderMarkersData, csvData, by="marker_number", all=FALSE, sort=FALSE)
  # this sorting order of the combinedData is essential for the successful execution 
  # of the below for-loop. If a different order is desired for presentation (eg. the 
  # marker_id before the error_estimate), this can be done at the very end of this 
  # for-loop (which iterates through the linkage groups), after the inner for-loop 
  # has been exited.
  combinedData <- combinedData[order(combinedData$marker_id, combinedData$error_estimate, combinedData$position), ]
#  print(combinedData[1:10,1:5])
#  write.csv(combinedData, paste(path.expand(path),paste0(csvFilenameMinusExtension,"-lg",lg,".csv"),sep="/"), row.names=FALSE)
  
  # library(stringr) required for str_split_fixed:
  combinedData$gene <- str_split_fixed(combinedData$marker_id,separatorForGeneNameVsMarkerId,2)[ ,1]

  # -----

  uniqueGenes <- unique(combinedData$gene)
  # create dataframe uniqueGenes(gene, total_markers, max_pos, min_pos, median_pos, total_distance,  median_distance, marker_id)
  numUniqueGenes <- length(uniqueGenes)
  uniqueGenes <- data.frame(gene = uniqueGenes, total_markers = numeric(numUniqueGenes), max_pos = numeric(numUniqueGenes), min_pos = numeric(numUniqueGenes), median_pos = numeric(numUniqueGenes), total_distance = numeric(numUniqueGenes), median_distance = numeric(numUniqueGenes), marker_id = numeric(numUniqueGenes))


  for (i in 1:nrow(uniqueGenes))
  {
    snpsInGene <- subset(combinedData, gene==uniqueGenes[i, "gene"])

    if (nrow(snpsInGene) == 1) 
    {
      uniqueGenes[i, "total_markers"] <- 1
      uniqueGenes[i, "max_pos"] <- snpsInGene[1, "position"]
      uniqueGenes[i, "min_pos"] <- snpsInGene[1, "position"]
      uniqueGenes[i, "median_pos"] <- snpsInGene[1, "position"]
      uniqueGenes[i, "total_distance"] <- 0
      uniqueGenes[i, "median_distance"] <- 0
      uniqueGenes[i, "marker_id"] <- snpsInGene[1, "marker_id"]
    }
    else
    {
      # ordering snpsInGene this way is necessary for calculating distancesBetweenPositions
      snpsInGene <- snpsInGene[order(snpsInGene$position), ] 

      uniqueGenes[i, "total_markers"] <- nrow(snpsInGene)
      uniqueGenes[i, "max_pos"] <- max(snpsInGene$position)
      uniqueGenes[i, "min_pos"] <- min(snpsInGene$position)
      uniqueGenes[i, "median_pos"] <- median(snpsInGene$position)
      uniqueGenes[i, "total_distance"] <- uniqueGenes[i, "max_pos"] - uniqueGenes[i, "min_pos"]
      
      # calculate the median distance between positions
      distancesBetweenPositions <- numeric(nrow(snpsInGene)-1)
      for (k in 2:nrow(snpsInGene))
      {
        distancesBetweenPositions[k-1] <- snpsInGene[k, "position"] - snpsInGene[k-1, "position"]
      }
      uniqueGenes[i, "median_distance"] <- median(distancesBetweenPositions)
      
      # find the snp(s) whose position match or are nearest to the median position:

      snpsOfMedianPosition <- subset(snpsInGene, position==uniqueGenes[i, "median_pos"])

      # if there are no snps whose position match the median position
      if ( is.null(snpsOfMedianPosition) | nrow(snpsOfMedianPosition) == 0 )
      {
        # find the snps directly above and below the median point, and get their positions.
        # snpsInGene is already ordered by position, so we can do this:
        indexOfSnpBelowMedian <- nrow(snpsInGene) %/% 2
        indexOfSnpAboveMedian <- indexOfSnpBelowMedian + 1
        positionBelowMedian <- snpsInGene[indexOfSnpBelowMedian, "position"]
        positionAboveMedian <- snpsInGene[indexOfSnpAboveMedian, "position"]

        snpsOfPositionBelowMedian <- subset(snpsInGene, position==positionBelowMedian)
        snpsOfPositionAboveMedian <- subset(snpsInGene, position==positionAboveMedian)
        
        # if one group is significantly larger than the other, use it
        if (nrow(snpsOfPositionBelowMedian) / nrow(snpsOfPositionAboveMedian) >= 1.5)
        {
          snpsOfMedianPosition <- snpsOfPositionBelowMedian
        }
        else if (nrow(snpsOfPositionAboveMedian) / nrow(snpsOfPositionBelowMedian) >= 1.5)
        {
          snpsOfMedianPosition <- snpsOfPositionAboveMedian
        }
        # else, use the following logic to pick a group
        else 
        {
          # remove any snp from each group whose error estimate is not equal to the lowest
          snpsOfPositionBelowMedian <- snpsOfPositionBelowMedian[order(snpsOfPositionBelowMedian$error_estimate), ]
          snpsOfPositionBelowMedian <- subset(snpsOfPositionBelowMedian, error_estimate==snpsOfPositionBelowMedian[1, "error_estimate"])

          snpsOfPositionAboveMedian <- snpsOfPositionAboveMedian[order(snpsOfPositionAboveMedian$error_estimate), ]
          snpsOfPositionAboveMedian <- subset(snpsOfPositionAboveMedian, error_estimate==snpsOfPositionAboveMedian[1, "error_estimate"])

          # if one group is significantly larger than the other, use it
          if (nrow(snpsOfPositionBelowMedian) / nrow(snpsOfPositionAboveMedian) >= 1.5)
          {
            snpsOfMedianPosition <- snpsOfPositionBelowMedian
          }
          else if (nrow(snpsOfPositionAboveMedian) / nrow(snpsOfPositionBelowMedian) >= 1.5)
          {
            snpsOfMedianPosition <- snpsOfPositionAboveMedian
          }
          # else use the one with the lowest error_estimate
          else if ( snpsOfPositionBelowMedian[1, "error_estimate"] < snpsOfPositionAboveMedian[1, "error_estimate"] )
          {
            snpsOfMedianPosition <- snpsOfPositionBelowMedian
          }
          else if ( snpsOfPositionAboveMedian[1, "error_estimate"] < snpsOfPositionBelowMedian[1, "error_estimate"] )
          {
            snpsOfMedianPosition <- snpsOfPositionBelowMedian
          }
          # else pick the one that's nearest the median, or if they're tied use the lower one
          else
          {
            distFromUpper <- snpsOfPositionAboveMedian[1, "position"] - uniqueGenes[i, "median_pos"]
            distFromLower <- uniqueGenes[i, "median_pos"] - snpsOfPositionBelowMedian[1, "position"]
            if (distFromLower <= distFromUpper)
            {
              snpsOfMedianPosition <- snpsOfPositionBelowMedian
            }
            else
            {
              snpsOfMedianPosition <- snpsOfPositionAboveMedian
            }
          }         
        }
      } # end of all logic to pick group of snps to represent the median position

      # choose the snp/marker in snpsOfMedianPosition with the (lowest error and) most complete data to represent the gene:

      # remove any snp from each group whose error estimate is not equal to the lowest
      snpsOfMedianPosition <- snpsOfMedianPosition[order(snpsOfMedianPosition$error_estimate), ]
      snpsOfMedianPosition <- subset(snpsOfMedianPosition, error_estimate==snpsOfMedianPosition[1, "error_estimate"])

      if (nrow(snpsOfMedianPosition) == 1)
      {
        uniqueGenes[i, "marker_id"] <- snpsOfMedianPosition[1, "marker_id"]
      }
      else
      {
        # we're going to use the one with the most complete data (least amount of missing data)
        naCounts <- NULL
        naCounts <- numeric(nrow(snpsOfMedianPosition))
        naCountsIndex = 1

        if (!is.na(missingDataIndicator))
        {
          if (missingDataIndicator == "NA")
          {
            missingDataIndicator <- NA
          }
        }

        if (!is.na(missingDataIndicator))
        {
          while (naCountsIndex <= nrow(snpsOfMedianPosition))
          {
            missingDataRegex <- paste0("^",missingDataIndicator,"$")
            naCounts[naCountsIndex] <- length(grep(missingDataRegex, snpsOfMedianPosition[naCountsIndex, 6:numDataColsInCsvData+5]))
            naCountsIndex <- naCountsIndex + 1
          }
        }
        else # it is NA
        {
          while (naCountsIndex <= nrow(snpsOfMedianPosition))
          {
            naCounts[naCountsIndex] <- length(grep(TRUE,is.na(snpsOfMedianPosition[naCountsIndex, 6:numDataColsInCsvData+5])))
            naCountsIndex <- naCountsIndex + 1
          }
        }

        uniqueGenes[i, "marker_id"]  <- snpsOfMedianPosition[which.min(naCounts), "marker_id"]
      }
      
    } # end of logic to populate the one row used to represent the current gene
  } # end inner for-loop


  # join uniqueGenes and combinedData by "marker_id"
  uniqueGenes <- merge(uniqueGenes, combinedData, by=c("gene","marker_id"), all=FALSE, sort=FALSE)

  # -----

  # remove unnecessary columns
  uniqueGenes <- subset(uniqueGenes , select=-c(duplicate_or_phases)) 

  # re-arrange the order of the columns so the marker_id column comes after all the summary columns. New order is: "gene","total_markers","max_pos","min_pos","median_pos","total_distance","median_distance","marker_id","marker_number","position","error_estimate",11:ncol(uniqueGenes)
  uniqueGenes <- uniqueGenes[ , c(1,3,4,5,6,7,8,2,9,10,11,12:ncol(uniqueGenes))]


  # add a linkage_group column to the beginning of the dataframe
  uniqueGenes <- cbind(linkage_group = lg, uniqueGenes)

  # add the current linkage group to the table containing all linkage groups
  if (nrow(uniqueGenes > 0))
  {
    if (is.null(finalUniqueGenes))
    {
      finalUniqueGenes <- uniqueGenes
    }
    else 
    {
      finalUniqueGenes <- rbind(finalUniqueGenes, uniqueGenes)
    }
  }
} # end outer for-loop (iterates through the linkage groups)


# after outer for-loop, remove all rows whose "gene" field occurs more than once in the table, and save their data in a new table
message("Separating genes that occur in more than one linkage group into their own table.")
geneOccurences <- table(finalUniqueGenes$gene)
genesThatOccureMoreThanOnce <- names(geneOccurences[geneOccurences>1])
genesInMultipleLGs <- finalUniqueGenes[finalUniqueGenes$gene %in% genesThatOccureMoreThanOnce, ]
finalUniqueGenes <- finalUniqueGenes[!(finalUniqueGenes$gene %in% genesThatOccureMoreThanOnce), ]

# order the genesInMultipleLGs data by gene first, then LG
genesInMultipleLGs <- genesInMultipleLGs[order(genesInMultipleLGs$gene,genesInMultipleLGs$linkage_group), ]


# output a stripped-down csv file that just has the data from the representative
# marker for each gene
representativeMarkers <- finalUniqueGenes[ , c(9,13:ncol(finalUniqueGenes))]
write.csv(representativeMarkers, paste(path.expand(path),paste0(csvFilenameMinusExtension,"-postLepMAP2-allChr-uniqueGenes-justTheMarkers.csv"),sep="/"), row.names=FALSE)

# build a map file that preserves the linkage group/gene relationship:
write(outputMapFileHeader, paste(path.expand(path),paste0(csvFilenameMinusExtension,"-postLepMAP2-uniqueGenes-map_js.txt"),sep="/"), ncolumns=1,append=FALSE)
write(finalUniqueGenes$linkage_group, paste(path.expand(path),paste0(csvFilenameMinusExtension,"-postLepMAP2-uniqueGenes-map_js.txt"),sep="/"), ncolumns=1,append=TRUE)


write.csv(genesInMultipleLGs, paste(path.expand(path),paste0(csvFilenameMinusExtension,"-postLepMAP2-allChr-genesInMoreThanOneLG.csv"),sep="/"), row.names=FALSE)

write.csv(finalUniqueGenes, paste(path.expand(path),paste0(csvFilenameMinusExtension,"-postLepMAP2-allChr-uniqueGenes.csv"),sep="/"), row.names=FALSE)


# To output a version of the output where our LG numbers match Pinus consensus LG numbers, we need to change:
# LG1->2
# LG2->1
# LG3->3
# LG4->8
# LG5->10
# LG6->4
# LG7->12
# LG8->6
# LG9->7
# LG10->11
# LG11->5
# LG12->9a
# LG13->9b

finalUniqueGenesWithUpdateLGs <- finalUniqueGenes

rowsPerOriginalLG <- list()
originalLGs <- unique(finalUniqueGenesWithUpdateLGs$linkage_group)
# record the row numbers of each LG
for (i in originalLGs) # this assumes that the original LGs are all numeric
{
  rowsPerOriginalLG[[ i ]] <- which(finalUniqueGenesWithUpdateLGs$linkage_group %in% i)
}

#update the LG's to match the Pinus consensus LG numbers
for (ourLG in originalLGs) # this assumes that the original LGs are all numeric
{
  if (ourLG == 1) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 2
  } else if (ourLG == 2) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 1
  } else if (ourLG == 3) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 3
  } else if (ourLG == 4) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 8
  } else if (ourLG == 5) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 10
  } else if (ourLG == 6) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 4
  } else if (ourLG == 7) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 12
  } else if (ourLG == 8) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 6
  } else if (ourLG == 9) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 7
  } else if (ourLG == 10) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 11
  } else if (ourLG == 11) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 5
  } else if (ourLG == 12) {
    if (length(originalLGs) < 13) {
      finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- 9
    } else {
      finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- "9a"
    }
  } else if (ourLG == 13) {
    finalUniqueGenesWithUpdateLGs[rowsPerOriginalLG[[ourLG]], "linkage_group"] <- "9b"
  }  

}

write.csv(finalUniqueGenesWithUpdateLGs, paste(path.expand(path),paste0(csvFilenameMinusExtension,"-postLepMAP2-allChr-uniqueGenes-PinusConsensusLGs.csv"),sep="/"), row.names=FALSE)

# build a map file that preserves the linkage group/gene relationship:
write(outputMapFileHeader, paste(path.expand(path),paste0(csvFilenameMinusExtension,"-postLepMAP2-uniqueGenes-PinusConsensusLGs-map_js.txt"),sep="/"), ncolumns=1,append=FALSE)
write(finalUniqueGenesWithUpdateLGs$linkage_group, paste(path.expand(path),paste0(csvFilenameMinusExtension,"-postLepMAP2-uniqueGenes-PinusConsensusLGs-map_js.txt"),sep="/"), ncolumns=1,append=TRUE)



message("tabulate_OrderMarkers_results complete.")
